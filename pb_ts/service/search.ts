// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.0
//   protoc               v5.29.2
// source: service/search.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "travelingman.service";

export interface SearchFlightRequest {
  origin: string;
  destination: string;
  departureDate: string;
  returnDate: string;
  adults: number;
  targetArrivalTime: string;
}

export interface SearchFlightResponse {
  /**
   * Returning raw JSON for now to allow frontend to parse full Amadeus schema
   * without rigid proto re-definition of every segment/fee/etc.
   */
  rawJson: Uint8Array;
}

export interface SearchHotelRequest {
  cityCode: string;
  hotelIds: string[];
  checkInDate: string;
  checkOutDate: string;
  adults: number;
}

export interface SearchHotelResponse {
  rawJson: Uint8Array;
}

export interface SearchTransferRequest {
  startLocationCode: string;
  endLocationCode: string;
  startDateTime: string;
  passengers: number;
}

export interface SearchTransferResponse {
  rawJson: Uint8Array;
}

function createBaseSearchFlightRequest(): SearchFlightRequest {
  return { origin: "", destination: "", departureDate: "", returnDate: "", adults: 0, targetArrivalTime: "" };
}

export const SearchFlightRequest: MessageFns<SearchFlightRequest> = {
  encode(message: SearchFlightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.origin !== "") {
      writer.uint32(10).string(message.origin);
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.departureDate !== "") {
      writer.uint32(26).string(message.departureDate);
    }
    if (message.returnDate !== "") {
      writer.uint32(34).string(message.returnDate);
    }
    if (message.adults !== 0) {
      writer.uint32(40).int32(message.adults);
    }
    if (message.targetArrivalTime !== "") {
      writer.uint32(50).string(message.targetArrivalTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFlightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFlightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.departureDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.returnDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.adults = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.targetArrivalTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFlightRequest {
    return {
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      departureDate: isSet(object.departureDate) ? globalThis.String(object.departureDate) : "",
      returnDate: isSet(object.returnDate) ? globalThis.String(object.returnDate) : "",
      adults: isSet(object.adults) ? globalThis.Number(object.adults) : 0,
      targetArrivalTime: isSet(object.targetArrivalTime) ? globalThis.String(object.targetArrivalTime) : "",
    };
  },

  toJSON(message: SearchFlightRequest): unknown {
    const obj: any = {};
    if (message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.departureDate !== "") {
      obj.departureDate = message.departureDate;
    }
    if (message.returnDate !== "") {
      obj.returnDate = message.returnDate;
    }
    if (message.adults !== 0) {
      obj.adults = Math.round(message.adults);
    }
    if (message.targetArrivalTime !== "") {
      obj.targetArrivalTime = message.targetArrivalTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchFlightRequest>, I>>(base?: I): SearchFlightRequest {
    return SearchFlightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchFlightRequest>, I>>(object: I): SearchFlightRequest {
    const message = createBaseSearchFlightRequest();
    message.origin = object.origin ?? "";
    message.destination = object.destination ?? "";
    message.departureDate = object.departureDate ?? "";
    message.returnDate = object.returnDate ?? "";
    message.adults = object.adults ?? 0;
    message.targetArrivalTime = object.targetArrivalTime ?? "";
    return message;
  },
};

function createBaseSearchFlightResponse(): SearchFlightResponse {
  return { rawJson: new Uint8Array(0) };
}

export const SearchFlightResponse: MessageFns<SearchFlightResponse> = {
  encode(message: SearchFlightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawJson.length !== 0) {
      writer.uint32(10).bytes(message.rawJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFlightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFlightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawJson = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFlightResponse {
    return { rawJson: isSet(object.rawJson) ? bytesFromBase64(object.rawJson) : new Uint8Array(0) };
  },

  toJSON(message: SearchFlightResponse): unknown {
    const obj: any = {};
    if (message.rawJson.length !== 0) {
      obj.rawJson = base64FromBytes(message.rawJson);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchFlightResponse>, I>>(base?: I): SearchFlightResponse {
    return SearchFlightResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchFlightResponse>, I>>(object: I): SearchFlightResponse {
    const message = createBaseSearchFlightResponse();
    message.rawJson = object.rawJson ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSearchHotelRequest(): SearchHotelRequest {
  return { cityCode: "", hotelIds: [], checkInDate: "", checkOutDate: "", adults: 0 };
}

export const SearchHotelRequest: MessageFns<SearchHotelRequest> = {
  encode(message: SearchHotelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cityCode !== "") {
      writer.uint32(10).string(message.cityCode);
    }
    for (const v of message.hotelIds) {
      writer.uint32(42).string(v!);
    }
    if (message.checkInDate !== "") {
      writer.uint32(18).string(message.checkInDate);
    }
    if (message.checkOutDate !== "") {
      writer.uint32(26).string(message.checkOutDate);
    }
    if (message.adults !== 0) {
      writer.uint32(32).int32(message.adults);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHotelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHotelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cityCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hotelIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkInDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checkOutDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.adults = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHotelRequest {
    return {
      cityCode: isSet(object.cityCode) ? globalThis.String(object.cityCode) : "",
      hotelIds: globalThis.Array.isArray(object?.hotelIds) ? object.hotelIds.map((e: any) => globalThis.String(e)) : [],
      checkInDate: isSet(object.checkInDate) ? globalThis.String(object.checkInDate) : "",
      checkOutDate: isSet(object.checkOutDate) ? globalThis.String(object.checkOutDate) : "",
      adults: isSet(object.adults) ? globalThis.Number(object.adults) : 0,
    };
  },

  toJSON(message: SearchHotelRequest): unknown {
    const obj: any = {};
    if (message.cityCode !== "") {
      obj.cityCode = message.cityCode;
    }
    if (message.hotelIds?.length) {
      obj.hotelIds = message.hotelIds;
    }
    if (message.checkInDate !== "") {
      obj.checkInDate = message.checkInDate;
    }
    if (message.checkOutDate !== "") {
      obj.checkOutDate = message.checkOutDate;
    }
    if (message.adults !== 0) {
      obj.adults = Math.round(message.adults);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchHotelRequest>, I>>(base?: I): SearchHotelRequest {
    return SearchHotelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchHotelRequest>, I>>(object: I): SearchHotelRequest {
    const message = createBaseSearchHotelRequest();
    message.cityCode = object.cityCode ?? "";
    message.hotelIds = object.hotelIds?.map((e) => e) || [];
    message.checkInDate = object.checkInDate ?? "";
    message.checkOutDate = object.checkOutDate ?? "";
    message.adults = object.adults ?? 0;
    return message;
  },
};

function createBaseSearchHotelResponse(): SearchHotelResponse {
  return { rawJson: new Uint8Array(0) };
}

export const SearchHotelResponse: MessageFns<SearchHotelResponse> = {
  encode(message: SearchHotelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawJson.length !== 0) {
      writer.uint32(10).bytes(message.rawJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHotelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHotelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawJson = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHotelResponse {
    return { rawJson: isSet(object.rawJson) ? bytesFromBase64(object.rawJson) : new Uint8Array(0) };
  },

  toJSON(message: SearchHotelResponse): unknown {
    const obj: any = {};
    if (message.rawJson.length !== 0) {
      obj.rawJson = base64FromBytes(message.rawJson);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchHotelResponse>, I>>(base?: I): SearchHotelResponse {
    return SearchHotelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchHotelResponse>, I>>(object: I): SearchHotelResponse {
    const message = createBaseSearchHotelResponse();
    message.rawJson = object.rawJson ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSearchTransferRequest(): SearchTransferRequest {
  return { startLocationCode: "", endLocationCode: "", startDateTime: "", passengers: 0 };
}

export const SearchTransferRequest: MessageFns<SearchTransferRequest> = {
  encode(message: SearchTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startLocationCode !== "") {
      writer.uint32(10).string(message.startLocationCode);
    }
    if (message.endLocationCode !== "") {
      writer.uint32(18).string(message.endLocationCode);
    }
    if (message.startDateTime !== "") {
      writer.uint32(26).string(message.startDateTime);
    }
    if (message.passengers !== 0) {
      writer.uint32(32).int32(message.passengers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startLocationCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endLocationCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startDateTime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.passengers = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTransferRequest {
    return {
      startLocationCode: isSet(object.startLocationCode) ? globalThis.String(object.startLocationCode) : "",
      endLocationCode: isSet(object.endLocationCode) ? globalThis.String(object.endLocationCode) : "",
      startDateTime: isSet(object.startDateTime) ? globalThis.String(object.startDateTime) : "",
      passengers: isSet(object.passengers) ? globalThis.Number(object.passengers) : 0,
    };
  },

  toJSON(message: SearchTransferRequest): unknown {
    const obj: any = {};
    if (message.startLocationCode !== "") {
      obj.startLocationCode = message.startLocationCode;
    }
    if (message.endLocationCode !== "") {
      obj.endLocationCode = message.endLocationCode;
    }
    if (message.startDateTime !== "") {
      obj.startDateTime = message.startDateTime;
    }
    if (message.passengers !== 0) {
      obj.passengers = Math.round(message.passengers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchTransferRequest>, I>>(base?: I): SearchTransferRequest {
    return SearchTransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchTransferRequest>, I>>(object: I): SearchTransferRequest {
    const message = createBaseSearchTransferRequest();
    message.startLocationCode = object.startLocationCode ?? "";
    message.endLocationCode = object.endLocationCode ?? "";
    message.startDateTime = object.startDateTime ?? "";
    message.passengers = object.passengers ?? 0;
    return message;
  },
};

function createBaseSearchTransferResponse(): SearchTransferResponse {
  return { rawJson: new Uint8Array(0) };
}

export const SearchTransferResponse: MessageFns<SearchTransferResponse> = {
  encode(message: SearchTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawJson.length !== 0) {
      writer.uint32(10).bytes(message.rawJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawJson = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTransferResponse {
    return { rawJson: isSet(object.rawJson) ? bytesFromBase64(object.rawJson) : new Uint8Array(0) };
  },

  toJSON(message: SearchTransferResponse): unknown {
    const obj: any = {};
    if (message.rawJson.length !== 0) {
      obj.rawJson = base64FromBytes(message.rawJson);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchTransferResponse>, I>>(base?: I): SearchTransferResponse {
    return SearchTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchTransferResponse>, I>>(object: I): SearchTransferResponse {
    const message = createBaseSearchTransferResponse();
    message.rawJson = object.rawJson ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
